# 포팅 매뉴얼


# [개요]

## 주요 기술 스택

### 1. **개발 환경**

| 항목 | 기술 |
| --- | --- |
| Android 앱 개발 | Kotlin, Jetpack Compose, WearOS (watch) |
| 백엔드 개발 | Java 17, Spring Boot 3.4.4, Node.js v22.14.0 |
| 인프라 기반 개발 | Docker 26.1.3, Docker Compose 1.29.2 |
| CI/CD 파이프라인 | Jenkins 2.508 |
| OS 환경 | Windows |

### 2. **운영 환경**

| 항목 | 기술 |
| --- | --- |
| 클라우드 인프라 | AWS EC2, AWS S3 |
| 서버 운영체제 | Ubuntu 22.04 |
| 리버스 프록시 | Nginx 1.27.5 |
| 데이터베이스 | PostgreSQL 17.4, Redis 7.4.2 |

### 3. **AI 서버**

| 항목 | 기술 |
| --- | --- |
| 언어 및 프레임워크 | Python 3.10, FastAPI 0.115.12 |
| 주요 라이브러리 | PyTorch, scikit-learn, numpy, pandas, PyWavelets 등 |
| API 서버 실행 | Uvicorn (standard) |
| 데이터 처리 방식 | IMU 센서 벡터 변환, 거리 기반 분류, 제스처 추론 등 |
| 보안 및 글로벌 배포 | Cloudflare (CDN, HTTPS, WAF) |

### 4. **로깅/모니터링 시스템**

| 항목 | 기술 |
| --- | --- |
| 대시보드 시각화 | Grafana 11.6.1 |
| 메트릭 수집 | Prometheus 3.4.0, Node Exporter 1.9.1, Spring Boot Actuator |
| 로그 수집 | Promtail 2.9.3 |
| 로그 저장/쿼리 | Loki 2.9.3 |
| 컨테이너 리소스 추적 | cAdvisor v0.49.1 |

### 5. **IoT 제어 기술**

| 항목 | 기술 |
| --- | --- |
| 방향 인식 및 공간 정보 | UWB (Ultra-Wideband) 기반 방향 인식 |
| IoT 플랫폼 연동 | SmartThings SDK API (외부 API 기반 디바이스 제어) |

### 6. **배포 전략 및 무중단 배포 구조**

| 항목 | 내용 |
| --- | --- |
| 배포 방식 | Blue/Green 무중단 배포 (색상 전환 기반) |
| 오케스트레이션 | Docker Compose 기반 multi-service orchestration |
| 프록시 전환 | `switch.sh`를 통한 Nginx 설정 업데이트 및 reload |
| 롤백 전략 | `rollback.sh` 실행 시 이전 버전 자동 복구 |
| readiness 확인 | `/actuator/health` API + `curl` 기반 상태 체크 |

### 7. **외부 연동 서비스/도구**

| 항목 | 설명 |
| --- | --- |
| Cloudflare | Cloudflare Tunnel을 이용해 로컬 AI 서버 외부 노출 |
| GitLab | CI 트리거 소스 |
| Jenkins | GitLab 연동 및 pipeline 자동화 |
| Docker Hub | 이미지 배포 레지스트리 |
| SmartThings API | IoT 디바이스 연동 SDK 및 인증 방식 문서화 가능 |

---

# [개발 환경 실행]

## 프로젝트 디렉토리 구조

```
BE/
├─auth-service
├─common-lib
│  ├─common-core
│  ├─common-redis
│  └─common-security    
├─deploy
│  ├─nginx
│  ├─postgres
│  ├─prometheus
│  ├─promtail
│  └─redis
├─dev
│  ├─nginx
│  ├─postgres
│  ├─prometheus
│  ├─promtail
│  └─redis
├─device-service
├─gateway-service
├─gesture-sensor-service
├─gesture-service
├─member-service
├─routine-service
├─scripts
│  └─dev
└─smartthings-service
```

## 환경 변수

### IntelliJ에서 Spring Profile 환경 변수 설정
  - `application.yml`에서 정의한DB 설정 등을 `.env` 파일로 분리했기 때문에 그냥 실행하면 오류!(IntelliJ는 실행할 때 `.env` 파일을 자동으로 불러오지 않음)
      
      ![Run → Edit Configurations… → Modify options → Environment variables](resource/image_0.png)
      
      Run → Edit Configurations… → Modify options → Environment variables
      
### 각 마이크로서비스의 Environment variables

  gateway-service
  ```
  TZ=Asia/Seoul;SPRING_PROFILES_ACTIVE=dev
  ```
  
  auth-service
  ```
  JWT_SECRET=3]IU#Bnm!ErdaNw83SpolmJ<g:^CW79e9baAR=|kLs-M"RkzT8X%Y0BYf[7PSJG;SPRING_PROFILES_ACTIVE=dev;TZ=Asia/Seoul
  ```
  
  member-service
  ```
  JWT_SECRET=3]IU#Bnm!ErdaNw83SpolmJ<g:^CW79e9baAR=|kLs-M"RkzT8X%Y0BYf[7PSJG;DB_NAME=member_db;DB_PASSWORD=ssafyd103member;DB_USER=member_user;SPRING_PROFILES_ACTIVE=dev;TZ=Asia/Seoul
  ```
  
  device-service
  ```
  DB_NAME=device_db;DB_PASSWORD=ssafyd103device;DB_USER=device_user;JWT_SECRET=3]IU#Bnm!ErdaNw83SpolmJ<g:^CW79e9baAR=|kLs-M"RkzT8X%Y0BYf[7PSJG;SPRING_PROFILES_ACTIVE=dev;TZ=Asia/Seoul
  ```
  
  routine-service
  ```
  DB_NAME=routine_db;DB_PASSWORD=ssafyd103routine;DB_USER=routine_user;JWT_SECRET=3]IU#Bnm!ErdaNw83SpolmJ<g:^CW79e9baAR=|kLs-M"RkzT8X%Y0BYf[7PSJG;SPRING_PROFILES_ACTIVE=dev;TZ=Asia/Seoul
  ```
  
  gesture-service
  ```
  DB_NAME=gesture_db;DB_PASSWORD=ssafyd103gesture;DB_USER=gesture_user;JWT_SECRET=3]IU#Bnm!ErdaNw83SpolmJ<g:^CW79e9baAR=|kLs-M"RkzT8X%Y0BYf[7PSJG;SPRING_PROFILES_ACTIVE=dev;TZ=Asia/Seoul
  ```
  
  gesture-sensor-service
  ```
  AWS_ACCESS_KEY_ID=AKIAQWHCPSXRBFI4TMMF;AWS_REGION=ap-northeast-2;AWS_SECRET_ACCESS_KEY=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;CLOUDFRONT_DOMAIN=d2zh8kn4686cr4.cloudfront.net;DB_NAME=gesture_db;DB_PASSWORD=ssafyd103gesture;DB_USER=gesture_user;JWT_SECRET=3]IU#Bnm!ErdaNw83SpolmJ<g:^CW79e9baAR=|kLs-M"RkzT8X%Y0BYf[7PSJG;S3_BUCKET_NAME=ssafy-lumos;SPRING_PROFILES_ACTIVE=dev;TZ=Asia/Seoul;GESTURE_CLASSIFICATION_SERVER_URL=https://lipit.store
  ```
    

## 인프라 설정

- BE/scripts/dev/test-infra.sh 스크립트를 실행하여 인프라 컨테이너 구동
    
  ```bash
  #!/bin/bash
  
  set -e
  
  docker-compose \
    -f dev/docker-compose.infrastructure.dev.yml \
    --env-file dev/.env.dev up -d
  
  docker-compose \
    -f dev/docker-compose.ingress.dev.yml \
    --env-file dev/.env.dev up -d
  ```
  
  ```
  CONTAINER ID   IMAGE                              COMMAND                   CREATED          STATUS                  PORTS                                    NAMES
  3a44e634a01c   gesture-classification             "uvicorn app.main:ap…"   29 minutes ago   Up 29 minutes           0.0.0.0:8000->8000/tcp                   lumos-gesture-classification
  4329273d5097   redis/redisinsight:latest          "./docker-entry.sh n…"   14 hours ago     Up 14 hours             5540/tcp                                 lumos-redis-insight
  88a7401f6b92   provectuslabs/kafka-ui:v0.7.2      "/bin/sh -c 'java --…"   14 hours ago     Up 14 hours             8080/tcp                                 lumos-kafka-ui
  01433e47c2a1   postgres:latest                    "docker-entrypoint.s…"   14 hours ago     Up 14 hours             0.0.0.0:5432->5432/tcp                   lumos-postgres
  3688a284988c   grafana/grafana:latest             "/run.sh"                 14 hours ago     Up 14 hours             3000/tcp                                 lumos-grafana
  06a3bb829153   prom/prometheus                    "/bin/prometheus --c…"   14 hours ago     Up 14 hours             9090/tcp                                 lumos-prometheus
  c44493c28f49   redis:latest                       "docker-entrypoint.s…"   14 hours ago     Up 14 hours             0.0.0.0:6379->6379/tcp                   lumos-redis
  77ca61f05bb6   gcr.io/cadvisor/cadvisor:v0.49.1   "/usr/bin/cadvisor -…"   14 hours ago     Up 14 hours (healthy)   8080/tcp                                 lumos-cadvisor
  560caae6ce4a   bitnami/kafka:3.7.0                "/opt/bitnami/script…"   14 hours ago     Up 14 hours             9092/tcp, 9094/tcp                       lumos-kafka-0
  1ebf4f693c87   prom/node-exporter                 "/bin/node_exporter"      14 hours ago     Up 14 hours             9100/tcp                                 lumos-node-exporter
  428cc309ea2a   grafana/loki:2.9.3                 "/usr/bin/loki -conf…"   14 hours ago     Up 14 hours             3100/tcp                                 lumos-loki
  3ed310473e69   bitnami/zookeeper:3.9.2            "/opt/bitnami/script…"   14 hours ago     Up 14 hours             2181/tcp, 2888/tcp, 3888/tcp, 8080/tcp   lumos-zookeeper-0
  bbca7c3d272e   grafana/promtail:2.9.3             "/usr/bin/promtail -…"   14 hours ago     Up 14 hours                                                      lumos-promtail
  ```
  docker ps 결과
    

## 프로젝트 실행

### 📌 방법 1) 각 프로젝트 별 IDE에서 실행

1. Spring 프로젝트
  - IntelliJ의 실행 버튼 클릭
2. Node.js(smartthings-service) 프로젝트
  - Visual Studio Code Terminal(혹은 powershell에서 프로젝트 경로 이동)에서 실행
        
      ```powershell
      cd BE/smartthings-service
      node src/app.js
      ```
        
3. gateway-service 접속 ⇒ [http://localhost:8080/webjars/swagger-ui/index.html](http://localhost/webjars/swagger-ui/index.html)

### 📌 방법 2) docker-compose 실행

1. Spring 프로젝트 빌드
  - BE/scripts/dev/build-all.sh 실행
  
    ```bash
    #!/bin/bash
    set -e
    
    # 빌드 대상 서비스 디렉토리 목록
    services=(
      "gateway-service"
      "auth-service"
      "device-service"
      "gesture-sensor-service"
      "gesture-service"
      "member-service"
      "routine-service"
    )
    
    # 각 서비스 디렉토리에서 빌드 실행
    for service in "${services[@]}"
    do
      service_path="../../$service"
      echo "🔨 Building $service..."
    
      if [ -f "$service_path/gradlew" ]; then
        (cd "$service_path" && ./gradlew clean build -x check)
      else
        echo "⚠️  $service_path/ 에 gradlew 파일이 없습니다. 건너뜁니다."
      fi
    
      echo ""
    done
    
    echo "✅ 모든 서비스 빌드 완료"
    ```
    
2. Docker 설치
  - [hub.docker.com](http://hub.docker.com) 계정 등록
  - Docker Desktop 설치
  - WSL2 사용 체크
      
      ![image.png](resource/image_1.png)
      
  - 리부팅 후 커널 업데이트
      
      ![image.png](resource/image_2.png)
        
3. docker-compose 실행
  - BE/scripts/dev/test-all.sh 실행 → 로컬 환경에서 테스트용 Blue/Green 무중단 배포 스크립트 구현
  
    ```bash
    #!/bin/bash
    set -e
    
    trap 'echo -e "\n❌ 에러 발생! 로그를 확인하세요."; read -p "Press enter to exit..."' ERR
    
    print_step() {
      echo -e "\n\033[1;36m[STEP] $1\033[0m"
    }
    
    COLOR_FILE="scripts/dev/current_color.txt"
    
    # 초기 상태 파일 없으면 blue로 시작
    if [ ! -f "$COLOR_FILE" ]; then
      echo "blue" > "$COLOR_FILE"
    fi
    
    CURRENT_COLOR=$(cat "$COLOR_FILE")
    NEXT_COLOR=$([[ "$CURRENT_COLOR" == "blue" ]] && echo "green" || echo "blue")
    
    print_step "0. 공용 인프라(infra + ingress) 실행"
    bash scripts/dev/test-infra.sh
    sleep 2
    
    print_step "1. 현재 운영 버전: $CURRENT_COLOR"
    echo "📦 현재 버전은 [$CURRENT_COLOR]입니다. 새로운 버전을 [$NEXT_COLOR]에 배포합니다."
    sleep 1
    
    print_step "2. 새 버전 [$NEXT_COLOR]에 배포 및 전환"
    bash scripts/dev/test-color.sh "$NEXT_COLOR"
    sleep 2
    
    print_step "3. 롤백 테스트 ($NEXT_COLOR → $CURRENT_COLOR)"
    bash scripts/dev/rollback-local.sh
    sleep 2
    
    print_step "4. 이미지/컨테이너 정리"
    echo "🧹 이미지/컨테이너 정리 중..."
    docker image prune -f
    docker container prune -f
    echo "✅ 정리 완료!"
    
    print_step "🎉 전체 테스트 완료! 브라우저에서 http://localhost 확인하세요"
    ```
    
4. gateway-service 접속 ⇒ [http://localhost/webjars/swagger-ui/index.html](http://localhost/webjars/swagger-ui/index.html)

---

# [운영 환경 배포]

## EC2 디렉토리 구조

```
/home/ubuntu/lumos/
├── data
│   └── certbot
├── init-letsencrypt.sh
├── nginx
│   └── nginx.conf
├── postgres
│   └── init.sql
├── prometheus
│   ├── prometheus.template.yml
│   └── prometheus.yml
├── promtail
│   └── config.yml
├── redis
│   └── redis.conf
├── docker-compose.blue.yml
├── docker-compose.green.yml
├── docker-compose.infrastructure.yml
├── docker-compose.ingress.yml
├── scripts
│   ├── current_color.txt
│   ├── deploy.yml
│   ├── switch.yml
│   └── rollback.yml
├── gesture-sensor-service
├── gesture-service
├── device-service
├── member-service
├── routine-service
└── smartthings-service
```

## 환경 변수

`docker-compose.yml`에서 `.env` 파일을 참조해서 자동으로 환경 변수 설정

### 각 마이크로서비스의 `.env`
  
  member-service
  ```
  SPRING_PROFILES_ACTIVE=prod
  
  DB_NAME=member_db
  DB_USER=member_user
  DB_PASSWORD=ssafyd103member
  
  TZ=Asia/Seoul
  
  JWT_SECRET='3]IU#Bnm!ErdaNw83SpolmJ<g:^CW79e9baAR=|kLs-M"RkzT8X%Y0BYf[7PSJG'
  JWT_ALGORITHM=HS256
  
  REDIS_HOST=redis
  REDIS_PORT=6379
  REDIS_PASSWORD=ssafyd103mjsrsj
  ```
  
  device-service
  ```
  SPRING_PROFILES_ACTIVE=prod
  
  DB_NAME=device_db
  DB_USER=device_user
  DB_PASSWORD=ssafyd103device
  
  TZ=Asia/Seoul
  
  JWT_SECRET='3]IU#Bnm!ErdaNw83SpolmJ<g:^CW79e9baAR=|kLs-M"RkzT8X%Y0BYf[7PSJG'
  JWT_ALGORITHM=HS256
  
  REDIS_HOST=redis
  REDIS_PORT=6379
  REDIS_PASSWORD=ssafyd103mjsrsj
  ```
  
  routine-service
  ```
  SPRING_PROFILES_ACTIVE=prod
  
  DB_NAME=routine_db
  DB_USER=routine_user
  DB_PASSWORD=ssafyd103routine
  
  TZ=Asia/Seoul
  
  JWT_SECRET='3]IU#Bnm!ErdaNw83SpolmJ<g:^CW79e9baAR=|kLs-M"RkzT8X%Y0BYf[7PSJG'
  JWT_ALGORITHM=HS256
  
  REDIS_HOST=redis
  REDIS_PORT=6379
  REDIS_PASSWORD=ssafyd103mjsrsj
  ```
  
  gesture-service
  ```
  SPRING_PROFILES_ACTIVE=prod
  
  DB_NAME=gesture_db
  DB_USER=gesture_user
  DB_PASSWORD=ssafyd103gesture
  
  TZ=Asia/Seoul
  
  JWT_SECRET='3]IU#Bnm!ErdaNw83SpolmJ<g:^CW79e9baAR=|kLs-M"RkzT8X%Y0BYf[7PSJG'
  JWT_ALGORITHM=HS256
  
  REDIS_HOST=redis
  REDIS_PORT=6379
  REDIS_PASSWORD=ssafyd103mjsrsj
  ```
  
  gesture-sensor-service
  ```
  SPRING_PROFILES_ACTIVE=prod
  
  DB_NAME=gesture_db
  DB_USER=gesture_user
  DB_PASSWORD=ssafyd103gesture
  
  TZ=Asia/Seoul
  
  JWT_SECRET='3]IU#Bnm!ErdaNw83SpolmJ<g:^CW79e9baAR=|kLs-M"RkzT8X%Y0BYf[7PSJG'
  JWT_ALGORITHM=HS256
  
  REDIS_HOST=redis
  REDIS_PORT=6379
  REDIS_PASSWORD=ssafyd103mjsrsj
  ```
  
  smartthings-service
  ```powershell
  # Node.js Port
  PORT=3000
  
  # SmartThings OAuth
  APP_ID=8f51d7f8-83cf-43f3-b5c9-e434ad8843c0
  CLIENT_ID=8ec4baf1-5c20-425d-9bb4-c015a47534aa
  CLIENT_SECRET=3df493a2-0e5f-4c2f-93a9-df9439c90ea3
  
  # SmartThings Device
  DEFAULT_INSTALLED_APP_ID=5f810cf2-432c-4c4c-bc72-c5af5abf1ef5
  DEFAULT_DEVICE_ID=4853843b-6958-4589-8e66-b7e1dae6dddf
  
  SERVER_URL=https://k12d103.p.ssafy.io
  API_URL=https://api.smartthings.com
  ```
        

## 인프라 설정

### nginx/nginx.conf

```yaml
worker_processes auto;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

	upstream grafana {
		server grafana:3000;
	}
	
	upstream prometheus {
		server prometheus:9090;
	}

    server {
		listen 443 ssl http2;
		server_name k12d103.p.ssafy.io;

		ssl_certificate /etc/letsencrypt/live/k12d103.p.ssafy.io/fullchain.pem;
		ssl_certificate_key /etc/letsencrypt/live/k12d103.p.ssafy.io/privkey.pem;
		include /etc/letsencrypt/options-ssl-nginx.conf;
		ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
		
        # URI 길이 체크 (server 블록 시작 부분에 배치)
        if ($request_uri ~* "^.{500,}$") {
            return 414;
        }
		
		# Grafana
		location /grafana/ {
			proxy_pass http://grafana/;
			proxy_set_header Host $host;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header X-Forwarded-Proto $scheme;
		}
		
		# Prometheus
		location /prometheus/ {
			proxy_pass http://prometheus/;
			rewrite ^/prometheus/?(.*) /$1 break;
			proxy_set_header Host $host;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_redirect / /prometheus/;
		}

		# Spring Gateway
		location / {
			proxy_pass http://lumos-gateway-service-blue:8080;
			proxy_set_header Host $host;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header X-Forwarded-Proto $scheme;
		}
	}

	server {
		listen 80;
		server_name k12d103.p.ssafy.io www.k12d103.p.ssafy.io;

		location /.well-known/acme-challenge/ {
			root /var/www/certbot;
			allow all;
			autoindex on;
			try_files $uri =404;
		}

		location ~ /\. {
		   deny all;  # 숨김 파일(.env, .htaccess 등) 접근 차단
		   return 404;
		}

		# HTTP 요청을 HTTPS로 리디렉션
		location / {
			return 301 https://$host$request_uri;
		}
	}
}
```

### postgres/init.sql

```sql
CREATE USER gesture_user WITH PASSWORD 'ssafyd103gesture';
CREATE DATABASE gesture_db OWNER gesture_user;

CREATE USER device_user WITH PASSWORD 'ssafyd103device';
CREATE DATABASE device_db OWNER device_user;

CREATE USER member_user WITH PASSWORD 'ssafyd103member';
CREATE DATABASE member_db OWNER member_user;

CREATE USER routine_user WITH PASSWORD 'ssafyd103routine';
CREATE DATABASE routine_db OWNER routine_user;
```

### prometheus/prometheus.template.yml

- 운영 중인 서비스 색상(blue/green)에 따라 동적으로 Prometheus 설정을 생성하는 템플릿 파일

```yaml
global:
  scrape_interval: 15s

scrape_configs:

  # Node Exporter
  - job_name: 'node'
    static_configs:
      - targets: ['lumos-node-exporter:9100']

  # cAdvisor
  - job_name: 'cadvisor'
    static_configs:
      - targets: ['lumos-cadvisor:8080']

  # Spring Boot Services (blue/green 모두 대응)
  - job_name: 'spring-services'
    metrics_path: /actuator/prometheus
    static_configs:
      - targets:
          - lumos-gateway-service-{{color}}:8080
          - lumos-auth-service-{{color}}:8080
          - lumos-member-service-{{color}}:8080
          - lumos-device-service-{{color}}:8080
          - lumos-gesture-service-{{color}}:8080
          - lumos-gesture-sensor-service-{{color}}:8080
          - lumos-routine-service-{{color}}:8080
    relabel_configs:
      - source_labels: [__address__]
        regex: 'lumos-(.*)-service-{{color}}:8080'
        target_label: instance
        replacement: '${1}-service-{{color}}'
      - source_labels: [__address__]
        regex: 'lumos-(.*)-service-{{color}}:8080'
        target_label: job
        replacement: '${1}'
```

### promtail/config.yml

```yaml
server:
  http_listen_port: 9080
  grpc_listen_port: 0

positions:
  filename: /tmp/positions.yaml

clients:
  - url: http://loki:3100/loki/api/v1/push

scrape_configs:
  - job_name: docker
    docker_sd_configs:
      - host: unix:///var/run/docker.sock
        refresh_interval: 5s

    pipeline_stages:
      # Node.js: lumos-smartthings-service → 멀티라인 처리 안 함
      - match:
          selector: '{container="lumos-smartthings-service"}'
          stages:
            - docker: {}

      # Spring: 그 외 lumos-xxx-service 컨테이너는 멀티라인 적용
      - match:
          selector: '{container=~"lumos-.*"}'
          stages:
            - multiline:
                firstline: '^\d{4}-\d{2}-\d{2}'
                max_wait_time: 3s
            - docker: {}

    relabel_configs:
      - source_labels: [__meta_docker_container_name]
        regex: lumos-loki
        action: drop

      - source_labels: [ '__meta_docker_container_name' ]
        regex: '/(.*)'
        target_label: container

      - source_labels: [ '__meta_docker_container_log_stream' ]
        target_label: stream
```

### redis/redis.conf

```
appendonly yes
appendfilename "appendonly.aof"
appendfsync everysec

save 900 1
save 300 10

maxmemory 1gb
maxmemory-policy allkeys-lru

replicaof no one
protected-mode no

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
aof-use-rdb-preamble yes
```

## Docker Compose 설정

### docker-compose.blue.yml

```yaml
services:

  # Spring Cloud Gateway
  gateway-service:
    image: itsanisland/lumos-gateway-service:blue
    container_name: lumos-gateway-service-blue
    ports:
      - "8081:8080"
    env_file:
      - .env.prod
    depends_on:
      - gesture-sensor-service
      - auth-service
      - member-service
      - device-service
      - gesture-service
      - routine-service
      - smartthings-service
    networks:
      - app-network

  # 제스처 센서 서비스
  gesture-sensor-service:
    image: itsanisland/lumos-gesture-sensor-service:blue
    container_name: lumos-gesture-sensor-service-blue
    expose:
      - "8080"  # 내부 통신용
    env_file:
      - .env.prod
      - ./gesture-sensor-service/.env
    networks:
      - app-network
  
  # 인증 서비스
  auth-service:
    image: itsanisland/lumos-auth-service:blue
    container_name: lumos-auth-service-blue
    expose:
      - "8080"
    env_file:
      - .env.prod
    networks:
      - app-network
  
  # 회원 서비스
  member-service:
    image: itsanisland/lumos-member-service:blue
    container_name: lumos-member-service-blue
    expose:
      - "8080"
    env_file:
      - ./member-service/.env
    networks:
      - app-network
  
  # 기기 서비스
  device-service:
    image: itsanisland/lumos-device-service:blue
    container_name: lumos-device-service-blue
    expose:
      - "8080"
    env_file:
      - ./device-service/.env
    networks:
      - app-network
  
  # 제스처 서비스
  gesture-service:
    image: itsanisland/lumos-gesture-service:blue
    container_name: lumos-gesture-service-blue
    expose:
      - "8080"
    env_file:
      - ./gesture-service/.env
    networks:
      - app-network
  
  # 루틴 서비스
  routine-service:
    image: itsanisland/lumos-routine-service:blue
    container_name: lumos-routine-service-blue
    expose:
      - "8080"
    env_file:
      - ./routine-service/.env
    networks:
      - app-network

  # SmartThings 서비스
  smartthings-service:
    image: itsanisland/lumos-smartthings-service:blue
    container_name: lumos-smartthings-service-blue
    expose:
      - "3000"
    env_file:
      - ./smartthings-service/.env
    volumes:
      - ./smartthings-service/data:/app/data
    networks:
      - app-network

networks:
  app-network:
    external: true
```

### docker-compose.green.yml

```yaml
services:

  # Spring Cloud Gateway
  gateway-service:
    image: itsanisland/lumos-gateway-service:green
    container_name: lumos-gateway-service-green
    ports:
      - "8082:8080"
    env_file:
      - .env.prod
    depends_on:
      - gesture-sensor-service
      - auth-service
      - member-service
      - device-service
      - gesture-service
      - routine-service
      - smartthings-service
    networks:
      - app-network

  # 제스처 센서 서비스
  gesture-sensor-service:
    image: itsanisland/lumos-gesture-sensor-service:green
    container_name: lumos-gesture-sensor-service-green
    expose:
      - "8080"  # 내부 통신용
    env_file:
      - .env.prod
      - ./gesture-sensor-service/.env
    networks:
      - app-network
  
  # 인증 서비스
  auth-service:
    image: itsanisland/lumos-auth-service:green
    container_name: lumos-auth-service-green
    expose:
      - "8080"
    env_file:
      - .env.prod
    networks:
      - app-network
  
  # 회원 서비스
  member-service:
    image: itsanisland/lumos-member-service:green
    container_name: lumos-member-service-green
    expose:
      - "8080"
    env_file:
      - ./member-service/.env
    networks:
      - app-network
  
  # 기기 서비스
  device-service:
    image: itsanisland/lumos-device-service:green
    container_name: lumos-device-service-green
    expose:
      - "8080"
    env_file:
      - ./device-service/.env
    networks:
      - app-network
  
  # 제스처 서비스
  gesture-service:
    image: itsanisland/lumos-gesture-service:green
    container_name: lumos-gesture-service-green
    expose:
      - "8080"
    env_file:
      - ./gesture-service/.env
    networks:
      - app-network
  
  # 루틴 서비스
  routine-service:
    image: itsanisland/lumos-routine-service:green
    container_name: lumos-routine-service-green
    expose:
      - "8080"
    env_file:
      - ./routine-service/.env
    networks:
      - app-network

  # SmartThings 서비스
  smartthings-service:
    image: itsanisland/lumos-smartthings-service:green
    container_name: lumos-smartthings-service-green
    expose:
      - "3000"
    env_file:
      - ./smartthings-service/.env
    volumes:
      - ./smartthings-service/data:/app/data
    networks:
      - app-network

networks:
  app-network:
    external: true
```

### docker-compose.infrastructure.yml

```yaml
version: "3.8"

services:

  postgres:
    image: postgres:latest
    container_name: lumos-postgres
    env_file:
      - .env.prod
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./postgres/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    networks:
      - app-network

  redis:
    image: redis:latest
    container_name: lumos-redis
    restart: always
    expose:
      - "6379"
    volumes:
      - redis_data:/data
      - ./redis/redis.conf:/usr/local/etc/redis/redis.conf
    command: [ "redis-server", "/usr/local/etc/redis/redis.conf" ]
    networks:
      - app-network

  redis-insight:
    image: redis/redisinsight:latest
    container_name: lumos-redis-insight
    restart: always
    expose:
      - "5540"
    volumes:
      - redis-insight-data:/data
    depends_on:
      - redis
    networks:
      - app-network

  grafana:
    image: grafana/grafana:latest
    container_name: lumos-grafana
    expose:
      - "3000"
    env_file:
      - .env.prod
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - app-network

  loki:
    image: grafana/loki:2.9.3
    container_name: lumos-loki
    expose:
      - "3100"
    command: -config.file=/etc/loki/local-config.yaml -log.level=warn
    networks:
      - app-network

  promtail:
    image: grafana/promtail:2.9.3
    container_name: lumos-promtail
    volumes:
      - /var/log:/var/log # 시스템 로그 접근
      - ./promtail:/etc/promtail
      - /var/run/docker.sock:/var/run/docker.sock
      - /var/lib/docker/containers:/var/lib/docker/containers:ro # 도커 로그 위치
    command: -config.file=/etc/promtail/config.yml
    networks:
      - app-network

  prometheus:
    image: prom/prometheus
    container_name: lumos-prometheus
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
    expose:
      - "9090"
    networks:
      - app-network

  node-exporter:
    image: prom/node-exporter:latest
    container_name: lumos-node-exporter
    expose:
      - "9100"
    networks:
      - app-network
    restart: always

  cadvisor:
    image: gcr.io/cadvisor/cadvisor:v0.49.1
    container_name: lumos-cadvisor
    expose:
      - "8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:ro
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
    command:
      - "--docker_only=true"
      - "--housekeeping_interval=10s"
      - "--store_container_labels=true"
      - "--allow_dynamic_housekeeping=true"
    networks:
      - app-network
    restart: always

volumes:
  postgres_data:
  grafana_data:
  redis_data:
  redis-insight-data:

networks:
  app-network:
    external: true
```

### docker-compose.ingress.yml

```yaml
version: "3.8"

services:

  nginx:
    image: nginx:latest
    container_name: lumos-nginx
    ports:
      - "80:80"
      - "443:443"
    command: "/bin/sh -c 'while :; do sleep 6h & wait $${!}; nginx -s reload; done & nginx -g \"daemon off;\"'"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./data/certbot/conf:/etc/letsencrypt
      - ./data/certbot/www:/var/www/certbot
    networks:
      - app-network

  certbot:
    image: certbot/certbot
    container_name: lumos-certbot
    volumes:
      - ./data/certbot/conf:/etc/letsencrypt
      - ./data/certbot/www:/var/www/certbot
    entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done;'"

networks:
  app-network:
    external: true

```

## Docker 설치

1. 시스템의 패키지 목록 업데이트 → 최신 보안업데이트까지 갱신
    
    ```bash
    sudo apt update
    sudo apt upgrade
    ```
    
2. docker, docker-compose 설치
    
    ```bash
    sudo apt install docker.io
    sudo apt install docker-compose
    ```
    

## CI/CD 파이프라인

### Jenkins container 생성 및 구동

1. 컨테이너에 마운트할 볼륨 디렉터리 생성
    
    ```bash
    cd /home/ubuntu && mkdir jenkins-data
    ```
    
2. 외부에서 접속할 포트를 오픈하고 상태를 확인
    
    ```bash
    sudo ufw allow 8080/tcp
    sudo ufw reload
    sudo ufw status
    ```
    
3. docker 명령어로 컨테이너 생성 및 구동
  - 해당 이미지가 없는 경우 다운로드가 진행되고 이미 있는 경우 생성된 컨테이너의 ID만 출력
    
    ```bash
    sudo docker run -d -p 9090:8080 -v /home/ubuntu/jenkins-data:/var/jenkins_home --name jenkins jenkins/jenkins:lts
    ```
    
4. 구동 상태를 보기 위해 로그 확인
  - 중간에 출력되는 초기 패스워드는 별도로 기록 → 이후 Jenkins 웹 접속 시 사용
    
    ```bash
    sudo docker logs jenkins
    ```
    
5. 일부 환경 설정을 변경하기 위해 컨테이너를 종료하고 상태 확인
    
    ```bash
    sudo docker stop jenkins
    sudo docker ps -a
    ```
    
6. jenkins-data 폴더로 이동
    
    ```bash
    cd /home/ubuntu/jenkins-data
    ```
    
7. update center에 필요한 CA 파일 다운로드
    
    ```bash
    mkdir update-center-rootCAs
    wget https://cdn.jsdelivr.net/gh/lework/jenkins-update-center/rootCA/update-center.crt -O ./update-center-rootCAs/update-center.crt
    ```
    
8. jenkins의 default 설정에서 **특정 미러 사이트로 대체**하도록 아래 명령어를 실행 (필수)
  - 아래 명령어를 수행 후 `hubson.model.UpdateCenter.xml` 파일을 열어 `https://raw.githubusercontent.com/lework/jenkins-update-center/master/updates/tencent/update-center.json`이 URL로 변경되었는지 확인
    
    ```bash
    sudo sed -i 's#https://updates.jenkins.io/update-center.json#https://raw.githubusercontent.com/lework/jenkins-update-center/master/updates/tencent/update-center.json#' ./hudson.model.UpdateCenter.xml
    ```
    
9. jenkins 서비스 구동 (필수)
  - jenkins가 재구동될 때 `hudson.model.UpdateCenter.xml`에 설정된 Update Site 경로로부터 플러그인 목록을 받아와 `jenkins홈/updates/default.json` 파일을 업데이트하고 해당 파일을 참조하여 설치 가능한 플러그인 목록을 보여주고 설치 시 URL을 참조
    
    ```bash
    sudo docker restart jenkins
    ```
    
10. jenkins 초기 설정 진행
  - [http://k12d103.p.ssafy.io:9090](http://k12d103.p.ssafy.io:9090)으로 Jenkins 웹 접속 후 초기 패스워드 입력
    
    <img src="resource/image_3.png" alt="설명" width="400"/>
    

### Jenkins Credentials

<img src="resource/image_4.png" alt="설명" width="500"/>

### lumos-pipeline

- GitLab의 release 브랜치에서 소스 코드를 가져와서
- 서비스별로 Docker 이미지 빌드 및 Docker Hub에 푸시
- 배포 설정 파일을 EC2 서버로 전송
- Blue/Green 무중단 방식으로 배포 수행

```
pipeline {
    agent any

    tools {
        gradle 'gradle'
    }

    environment {
        REGISTRY = 'itsanisland'
        PROJECT_NAME = 'lumos'
        SPRING_PROFILES = 'prod'
        EC2_HOST = '172.26.7.51'
        EC2_USER = "ubuntu"
        PROJECT_DIR = '/home/ubuntu/lumos'
        BACKEND_DIR = './BE'
		DEPLOY_DIR = './BE/deploy'
    }

    stages {
        stage('Checkout') {
            steps {
                git credentialsId: 'gitlab-credentials', 
                    branch: 'release',
                    url: 'https://lab.ssafy.com/s12-final/S12P31D103.git'
            }
        }
        
        stage('Detect Current Color') {
            steps {
                withCredentials([sshUserPrivateKey(credentialsId: 'ec2-ssh-key', keyFileVariable: 'SSH_KEY')]) {
                    script {
                        def currentColor = sh(
                            script: "ssh -i ${SSH_KEY} ${EC2_USER}@${EC2_HOST} 'cat ${PROJECT_DIR}/scripts/current_color.txt'",
                            returnStdout: true
                        ).trim()
                        def nextColor = (currentColor == "blue") ? "green" : "blue"

                        env.CURRENT_COLOR = currentColor
                        env.DOCKER_TAG = nextColor

                        echo "🟢 현재 운영 중 색상: ${CURRENT_COLOR}"
                        echo "🆕 다음 배포 색상: ${DOCKER_TAG}"
                    }
                }
            }
        }

        stage('Build & Push Docker Images') {
            steps {
                script {
                    def services = [
                        'gateway-service',
                        'auth-service',
                        'member-service',
                        'device-service',
                        'gesture-service',
                        'gesture-sensor-service',
                        'routine-service',
                        'smartthings-service' // Node.js
                    ]

                    services.each { service ->
                        dir("BE/${service}") {
                            if (service != 'smartthings-service') {
                                // Spring Boot 빌드
                                sh """
                                echo "▶ Spring 서비스 빌드: ${service}"
                                chmod +x ./gradlew
                                ./gradlew clean build -x test -Dspring.profiles.active=${SPRING_PROFILES}
                                """
                            }

                            // Docker 빌드 & 푸시
                            sh """
                            echo "🐳 Docker 이미지 빌드 & 푸시: ${service}"
                            docker build -t ${REGISTRY}/${PROJECT_NAME}-${service}:${DOCKER_TAG} .
                            docker push ${REGISTRY}/${PROJECT_NAME}-${service}:${DOCKER_TAG}
                            """
                        }
                    }
                }
            }
        }

        stage('Deploy to EC2') {
            steps {
                withCredentials([sshUserPrivateKey(credentialsId: 'ec2-ssh-key', keyFileVariable: 'SSH_KEY')]) {
                    script {
                        sh """
                        echo "📦 EC2로 배포 리소스 전송"
                        scp -i ${SSH_KEY} -o StrictHostKeyChecking=no \\
                          ${DEPLOY_DIR}/docker-compose.*.yml \\
                          ${DEPLOY_DIR}/nginx/nginx.conf \\
                          ${DEPLOY_DIR}/redis/redis.conf \\
                          ${DEPLOY_DIR}/prometheus/*.yml \\
                          ${DEPLOY_DIR}/promtail/config.yml \\
                          ${BACKEND_DIR}/scripts/*.sh \\
                          ${EC2_USER}@${EC2_HOST}:/tmp/
                        """

                        echo "🚀 EC2에서 배포 스크립트 실행"
                        sh """
                        ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} \\
                          "bash /tmp/deploy.sh ${DOCKER_TAG}"
                        """
                    }
                }
            }
        }
    }

    post {
        success {
            echo '✅ 전체 배포 성공!'
        }
        failure {
            echo '❌ 실패: 빌드 또는 배포 중 오류 발생'
        }
    }
}
```

### lumos-env

EC2 서버에 `.env` 파일, DB 초기화 SQL 스크립트 등을 1회성으로 업로드 및 설정

```
pipeline {
    agent any

    environment {
        EC2_IP = "172.26.7.51"
        PROJECT_DIR = "/home/ubuntu/lumos"
    }

    stages {
        stage('Copy .env, init.sql, and service .env files to EC2 (one-time)') {
            steps {
                withCredentials([
                    file(credentialsId: 'common-env', variable: 'COMMON_ENV'),
                    file(credentialsId: 'postgres-init', variable: 'INIT_SQL_FILE'),
                    sshUserPrivateKey(credentialsId: 'ec2-ssh-key', keyFileVariable: 'SSH_KEY_PATH')
                ]) {
                    script {
                        def services = ['gesture-sensor-service', 'member-service', 'device-service', 'gesture-service', 'routine-service', 'smartthings-service']

                        // 공통 파일 전송 (홈 디렉토리로)
                        sh """
                            scp -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no $COMMON_ENV ubuntu@${EC2_IP}:~/common.env
                            scp -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no $INIT_SQL_FILE ubuntu@${EC2_IP}:~/init.sql
                        """

                        // 서비스별 .env 전송
                        services.each { service ->
                            def credId = "${service}-env"
                            withCredentials([file(credentialsId: credId, variable: 'ENV_FILE')]) {
                                sh """
                                    scp -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \$ENV_FILE ubuntu@${EC2_IP}:~/env-${service}.env
                                """
                            }
                        }

                        // EC2 내 파일 이동 및 권한 설정
                        def setupCommands = """
                            set -e
                            echo "📦 파일 이동 시작"

                            sudo mkdir -p ${PROJECT_DIR}/postgres
                            sudo mv ~/common.env ${PROJECT_DIR}/.env.prod
                            sudo mv ~/init.sql ${PROJECT_DIR}/postgres/init.sql
                            sudo chmod 644 ${PROJECT_DIR}/postgres/init.sql
                        """

                        setupCommands += services.collect { service -> """
                            sudo mkdir -p ${PROJECT_DIR}/${service}
                            sudo mv ~/env-${service}.env ${PROJECT_DIR}/${service}/.env
                            sudo chmod 600 ${PROJECT_DIR}/${service}/.env
                            sudo chown ubuntu:ubuntu ${PROJECT_DIR}/${service}/.env
                        """ }.join('\n')

                        setupCommands += """
                            sudo chown -R ubuntu:ubuntu ${PROJECT_DIR}
                            echo "✅ 모든 파일 이동 및 권한 설정 완료"
                        """

                        // SSH 명령 실행
                        sh """
                            ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no ubuntu@${EC2_IP} '${setupCommands}'
                        """
                    }
                }
            }
        }
    }
}
```

### lumos-rollback

현재 운영 중이던 색상(blue/green)이 아닌 이전 버전으로 롤백할 수 있도록 `rollback.sh`를 원격 실행

```
pipeline {
    agent any

    environment {
        EC2_HOST = '172.26.7.51'
        EC2_USER = 'ubuntu'
        PROJECT_DIR = '/home/ubuntu/lumos'
    }

    stages {
        stage('Rollback') {
            steps {
                withCredentials([sshUserPrivateKey(credentialsId: 'ec2-ssh-key', keyFileVariable: 'SSH_KEY')]) {
                    sh """
                    echo '🚨 롤백 시작...'
                    ssh -o StrictHostKeyChecking=no -i ${SSH_KEY} ${EC2_USER}@${EC2_HOST} \\
                      'cd ${PROJECT_DIR} && chmod +x ./scripts/rollback.sh && ./scripts/rollback.sh'
                    echo '✅ 롤백 완료!'
                    """
                }
            }
        }
    }

    post {
        success { echo '✅ 롤백 성공!' }
        failure { echo '❌ 롤백 실패' }
    }
}
```

### GitLab Webhook 등록

 1. Jenkins plugin 설치

- Jenkins관리 → Plugins 클릭
  
  ![image.png](resource/image_5.png)

1. Gitlab Access Token 발급
  - Gitlab 계정 - Settings - Access Tokens 발급
2. 파이프라인 연결
  - Generate 버튼을 클릭 후 jenkins secret token 생성
        
      ![image.png](resource/image_6.png)
        
  - GitLab Webhook 등록
    - GitLab 프로젝트 → setting → webhook
        
      ![image.png](resource/image_7.png)
        

## 무중단 Blue/Green 배포 자동화 스크립트

### deploy.sh

새로운 색상 버전으로 애플리케이션을 배포하고 readiness 체크 후 Nginx 프록시 전환 및 이전 버전 정리까지 수행하여 전체 배포 프로세스 자동화

```bash
#!/bin/bash
set -e

COLOR=$1

if [[ "$COLOR" != "blue" && "$COLOR" != "green" ]]; then
  echo "❌ 사용법: ./deploy.sh [blue|green]"
  exit 1
fi

# ==========================================
# 프로젝트 디렉토리 정의
# ==========================================
PROJECT_DIR="/home/ubuntu/lumos"
COLOR_FILE="$PROJECT_DIR/scripts/current_color.txt"
NGINX_CONF="$PROJECT_DIR/nginx/nginx.conf"
NGINX_CONTAINER_NAME="lumos-nginx"

# ==========================================
# 배포 파일 이동
# ==========================================
echo "📁 배포 파일 이동 및 정리"
mkdir -p $PROJECT_DIR/{nginx,redis,prometheus,promtail,scripts}

sudo mv /tmp/docker-compose.*.yml $PROJECT_DIR/
sudo mv /tmp/nginx.conf $PROJECT_DIR/nginx/nginx.conf
sudo mv /tmp/redis.conf $PROJECT_DIR/redis/redis.conf
sudo mv /tmp/prometheus.template.yml $PROJECT_DIR/prometheus/prometheus.template.yml
sudo mv /tmp/prometheus.yml $PROJECT_DIR/prometheus/prometheus.yml
sudo mv /tmp/config.yml $PROJECT_DIR/promtail/config.yml
sudo mv /tmp/*.sh $PROJECT_DIR/scripts/
sudo chmod +x $PROJECT_DIR/scripts/*.sh

cd $PROJECT_DIR

# ==========================================
# 상태 파일이 없으면 초기화
# ==========================================
if [ ! -f "$COLOR_FILE" ]; then
  echo "blue" > "$COLOR_FILE"
fi

CURRENT_COLOR=$(cat "$COLOR_FILE")
PREV_COLOR=$([[ "$CURRENT_COLOR" == "blue" ]] && echo "green" || echo "blue")
PORT=$([[ "$PREV_COLOR" == "blue" ]] && echo 8081 || echo 8082)

echo "⏪ 색상 전환 시작: 현재 $CURRENT_COLOR → 배포 대상 $PREV_COLOR"

# ==========================================
# Docker 네트워크 확인
# ==========================================
echo "🌐 Docker 네트워크 확인"
sudo docker network ls | grep -q app-network || sudo docker network create app-network

# ==========================================
# 공용 인프라 서비스 실행
# ==========================================
echo "🧱 공용 인프라(infra + ingress) 실행"
sudo docker-compose \
  -f $PROJECT_DIR/docker-compose.infrastructure.yml \
  --env-file $PROJECT_DIR/.env.prod up -d

sudo docker-compose \
  -f $PROJECT_DIR/docker-compose.ingress.yml \
  --env-file $PROJECT_DIR/.env.prod up -d

# ==========================================
# 앱 실행 (새로운 버전)
# ==========================================
echo "▶ $PREV_COLOR 앱 실행..."
sudo docker-compose \
  --project-name "$PREV_COLOR" \
  -f "$PROJECT_DIR/docker-compose.$PREV_COLOR.yml" \
  --env-file "$PROJECT_DIR/.env.prod" up -d --no-recreate

# ==========================================
# readiness 체크
# ==========================================
echo "⏳ Gateway 준비 대기 중..."

until curl -skL http://localhost:$PORT/actuator/health | grep '"status":"UP"' > /dev/null && \
      [ "$(curl -skL -L -o /dev/null -w "%{http_code}" http://localhost:$PORT)" = "200" ]; do
  echo "   🔄 아직 gateway ($PREV_COLOR:$PORT) 준비 안 됨..."
  sleep 1
done

echo "✅ Gateway ($PREV_COLOR) 완전 기동 완료!"

# ==========================================
# Nginx 프록시 전환
# ==========================================
echo "🔄 프록시 전환 (switch.sh 실행)"
sudo bash "$PROJECT_DIR/scripts/switch.sh"

# ==========================================
# 프록시 응답 확인
# ==========================================
echo "🌐 프록시 응답 확인 중..."
until curl -skL http://localhost/actuator/health | grep -q '"status":"UP"'; do
  echo "   🔄 프록시 대상 응답 없음... 기다리는 중..."
  sleep 1
done

# ==========================================
# 이전 앱 종료
# ==========================================
echo "🧹 $CURRENT_COLOR 앱 종료 중..."
bash "$PROJECT_DIR/scripts/cleanup.sh" "$CURRENT_COLOR"

echo "🧹 이미지 정리 중..."
sudo docker image prune -f
echo "✅ 정리 완료!"

echo "✅ 배포 완료: 현재 운영은 $PREV_COLOR 입니다."
```

### switch.sh

현재 실행 중인 gateway 서비스를 기반으로 Nginx의 프록시 대상(`proxy_pass`)을 다음 색상(gateway 컨테이너)으로 전환

```bash
#!/bin/bash

set -e

# ======================
# 설정
# ======================
COLOR_FILE="./scripts/current_color.txt"
NGINX_CONF="./nginx/nginx.conf"
NGINX_CONTAINER_NAME="lumos-nginx"
GATEWAY_SERVICE_PREFIX="lumos-gateway-service"

# ======================
# 유효성 검사
# ======================
if [ ! -f "$COLOR_FILE" ]; then
  echo "blue" > "$COLOR_FILE"
fi

if [ ! -f "$NGINX_CONF" ]; then
  echo "❌ nginx.conf 파일이 없습니다: $NGINX_CONF"
  exit 1
fi

CURRENT_COLOR=$(cat "$COLOR_FILE")

# ======================
# 살아있는 gateway 컨테이너 확인
# ======================
gateway_exists() {
  sudo docker ps --format '{{.Names}}' | grep -q "$1"
}

if gateway_exists "${GATEWAY_SERVICE_PREFIX}-green"; then
  TARGET_COLOR="green"
elif gateway_exists "${GATEWAY_SERVICE_PREFIX}-blue"; then
  TARGET_COLOR="blue"
else
  echo "❌ gateway 서비스가 모두 꺼져 있어 전환할 수 없습니다."
  exit 1
fi

if [ "$CURRENT_COLOR" == "$TARGET_COLOR" ]; then
  echo "ℹ️ 현재 프록시 상태($CURRENT_COLOR)와 동일하므로 전환하지 않습니다."
  exit 0
fi

echo "▶ Switching from $CURRENT_COLOR to $TARGET_COLOR"

# ======================
# nginx.conf proxy_pass 및 upstream 강제 변경
# ======================
sudo sed -i "s|proxy_pass http://lumos-gateway-service-[a-z]\+:8080;|proxy_pass http://lumos-gateway-service-${TARGET_COLOR}:8080;|" "$NGINX_CONF"
sudo sed -i "s|server lumos-gateway-service-[a-z]\+:8080;|server lumos-gateway-service-${TARGET_COLOR}:8080;|" "$NGINX_CONF"

# ======================
# 변경 확인
# ======================
echo "📝 nginx.conf 프록시 대상 변경됨:"
grep "lumos-gateway-service" "$NGINX_CONF"

# ======================
# Nginx Reload
# ======================
if sudo docker ps --format '{{.Names}}' | grep -q "$NGINX_CONTAINER_NAME"; then
  echo "🔍 nginx 설정 문법 검사"
  if ! sudo docker exec "$NGINX_CONTAINER_NAME" nginx -t; then
    echo "❌ 문법 오류 → nginx 재시작 중단"
    exit 1
  fi

  # 항상 restart로 새로고침
  echo "🔄 Restarting Nginx (upstream 캐시 초기화 포함)"
  sudo docker restart "$NGINX_CONTAINER_NAME"
else
  echo "❌ nginx 컨테이너 $NGINX_CONTAINER_NAME 이 존재하지 않습니다."
  exit 1
fi

# ======================
# 상태 파일 갱신
# ======================
echo "$TARGET_COLOR" | sudo tee "$COLOR_FILE" > /dev/null

# ======================
# 응답 확인
# ======================
echo "⏳ 프록시 전환 후 $TARGET_COLOR 응답 대기 중..."

RETRY=0
MAX_RETRY=60
while ! curl -skL -o /dev/null -w "%{http_code}" http://localhost/ | grep -q 200; do
  echo "   🔄 아직 $TARGET_COLOR 응답 없음... 기다리는 중..."
  sleep 1
  RETRY=$((RETRY+1))
  if [ "$RETRY" -ge "$MAX_RETRY" ]; then
    echo "❌ $TARGET_COLOR 서비스가 일정 시간 안에 응답하지 않음. 중단합니다."
    exit 1
  fi
done

echo "✅ Nginx now proxies to: $TARGET_COLOR"

# ======================
# Prometheus 설정 갱신
# ======================
if [ -x ./scripts/generate-prometheus-config.sh ]; then
  sudo bash ./scripts/generate-prometheus-config.sh
else
  echo "⚠️ Prometheus 설정 스크립트가 존재하지 않거나 실행 권한이 없습니다."
fi
```

### rollback.sh

현재 운영 중인 색상이 실패했을 때 이전 색상으로 gateway와 nginx 프록시를 안정적으로 롤백

```bash
#!/bin/bash
set -e

# ========================
# 설정
# ========================
COLOR_FILE="./scripts/current_color.txt"
NGINX_CONF="./nginx/nginx.conf"
NGINX_CONTAINER_NAME="lumos-nginx"

if [ ! -f "$COLOR_FILE" ]; then
  echo "🚫 current_color.txt가 없습니다. 롤백할 수 없습니다."
  exit 1
fi

CURRENT_COLOR=$(cat "$COLOR_FILE")
PREV_COLOR=$([ "$CURRENT_COLOR" == "blue" ] && echo "green" || echo "blue")
PORT=$([ "$PREV_COLOR" == "blue" ] && echo 8081 || echo 8082)

echo "⏪ 롤백 시작: 현재 $CURRENT_COLOR → 이전 $PREV_COLOR"

# ========================
# 1. 이전 앱 재실행
# ========================
echo "▶ $PREV_COLOR 앱 실행..."
sudo docker-compose \
  --project-name "$PREV_COLOR" \
  -f ./docker-compose.$PREV_COLOR.yml \
  --env-file .env.prod up -d --no-recreate

# ========================
# 2. readiness 체크
# ========================
echo "⏳ [WAIT] gateway 완전 기동 대기 중..."

until curl -skL http://localhost:$PORT/actuator/health | grep '"status":"UP"' > /dev/null && \
      [ "$(curl -skL -L -o /dev/null -w "%{http_code}" http://localhost:$PORT)" = "200" ]; do
  echo "   🔄 아직 gateway ($PREV_COLOR:$PORT) 준비 안 됨..."
  sleep 1
done

echo "✅ Gateway ($PREV_COLOR) 완전 기동 완료!"

# ========================
# 3. nginx.conf 전환
# ========================
if grep -q "server lumos-gateway-service-$CURRENT_COLOR:8080;" "$NGINX_CONF"; then
  echo "🔧 nginx.conf에서 gateway upstream 전환"
  sudo sed -i "s/server lumos-gateway-service-$CURRENT_COLOR:8080;/server lumos-gateway-service-$PREV_COLOR:8080;/" "$NGINX_CONF"
else
  echo "ℹ️ nginx.conf에는 이미 $PREV_COLOR가 설정되어 있습니다."
fi

# ========================
# 4. Nginx Reload
# ========================
if sudo docker ps --format '{{.Names}}' | grep -q "$NGINX_CONTAINER_NAME"; then
  echo "🔄 Nginx Reload (in $NGINX_CONTAINER_NAME)"
  if ! sudo docker exec "$NGINX_CONTAINER_NAME" nginx -s reload; then
    echo "⚠️ reload 실패 → nginx 컨테이너 재시작"
    sudo docker restart "$NGINX_CONTAINER_NAME"
  fi
else
  echo "❌ Nginx 컨테이너가 존재하지 않습니다. 롤백 중단"
  exit 1
fi

# ========================
# 5. 프록시 반영 확인
# ========================
echo "⏳ 프록시 전환 반영 대기 중..."

until curl -skL http://localhost/actuator/health | grep -q '"status":"UP"'; do
  echo "   🔄 프록시 대상 응답 없음... 기다리는 중..."
  sleep 1
done

# ========================
# 6. 상태 기록 갱신
# ========================
echo "$PREV_COLOR" | sudo tee $COLOR_FILE > /dev/null

# ========================
# 7. 현재 앱 종료
# ========================
echo "🧹 $CURRENT_COLOR 앱 종료 중..."
bash ./scripts/cleanup.sh "$CURRENT_COLOR"

# Prometheus 설정 자동 생성
sudo bash ./scripts/generate-prometheus-config.sh

echo "✅ 롤백 완료: 현재 운영은 $PREV_COLOR 입니다."
```

---

# [제스처 인식 모델 서버]

## 실행

1. 패키지 설치

    ```
    fastapi
    uvicorn[standard]
    torch
    pydantic
    numpy
    scikit-learn
    PyWavelets
    pandas
    ```
    requirements.txt

    ```bash
    python -r requirments.txt
    ```

2. Docker Build & Run

    ```bash
    #!/bin/bash

    set -e

    IMAGE_NAME="gesture-classification"
    CONTAINER_NAME="lumos-gesture-classification"

    # 경로는 슬래시(/) 또는 따옴표로 명확히 처리
    HOST_PATH="C:/SSAFY/PJT/S12P31D103/AI/app"

    # 1. 기존 컨테이너 정리
    docker stop $CONTAINER_NAME 2>/dev/null || true
    docker rm $CONTAINER_NAME 2>/dev/null || true

    # 2. 이미지 빌드 (필요 시)
    docker build -t $IMAGE_NAME .

    # 3. 컨테이너 실행
    docker run -d --name $CONTAINER_NAME -p 8000:8000 -v "$HOST_PATH":/app/app --gpus all $IMAGE_NAME
    ```
    AI/docker-build-run.sh

3. 실시간 로그 확인
    
    ```powershell
    docker logs -f lumos-gesture-classification
    ```
    

## 배포

> 빠르게 개발하고 실시간으로 결과를 테스트하기 위해서 서버를 따로 구축해서 사용
또한 실시간 빠른 추론을 위한 GPU 자원 활용 가능
> 
1. Cloudflare 설치 및 인증(최초 1회 필요)
    
    ```bash
    # 인증
    cloudflared login
    
    # ~/.cloudflared/cert.pem 파일 생성 확인
    ```
    
2. `~/.cloudflared/config.yml` 파일 수정
    
    ```bash
    tunnel: lumos-tunnel  # 만든 tunnel 이름
    credentials-file: C:\Users\SSAFY\.cloudflared\e65a037e-18ea-4ab0-89a4-4c2df1bcc5f3.json
    
    ingress:
      - hostname: lipit.store
        service: http://127.0.0.1:9000  # FastAPI 서버가 실행되는 주소/포트
      - service: http_status:404
    ```
    
3. Docker Container 실행
    
    ```bash
    # Docker Image Pull
    docker pull itsanisland/lipit-tts
    
    # Docker Image Run
    docker run --name itsanisland/lipit-tts -p 9000:8000 --gpus all lipit-tts
    ```
    
4. Cloudflare 배포
    
    ```bash
    # Tunnel 생성
    cloudflared tunnel create lumos-tunnel
    
    # 도메인 연결
    cloudflared tunnel route dns lumos-tunnel lipit.store
    
    # 실행
    cloudflared tunnel run lumos-tunnel
    ```
    
5. Postman으로 [lipit.store](http://lipit.store) 웹 소켓 연결 여부 확인
    
    ```
    wss://lipit.store/ws/gesture
    ```
    

---

# [로깅/모니터링 시스템]

## 작동 흐름

### 메트릭 수집 (모니터링)

1. **Spring Boot Actuator**
    - 각 서비스는 `/actuator/prometheus` 엔드포인트를 통해 JVM, 요청 수, 에러율 등의 애플리케이션 메트릭 제공
2. **Node Exporter / cAdvisor**
    - EC2 및 Docker 컨테이너의 CPU, 메모리, 디스크, 네트워크 사용량 수집
3. **Prometheus**
    - `prometheus.yml`에 등록된 타겟 주소로 주기적으로 scrape
    - 이 모든 메트릭을 내부 시계열 DB에 저장

### 로그 수집 (로깅)

1. **Docker 로그 출력 (`stdout`)**
    - Spring/Nginx 등의 로그는 모두 컨테이너의 표준 출력으로 수집됨
2. **Promtail**
    - Docker 로그 경로(`/var/lib/docker/containers/...`)를 tail하며 로그 수집
    - 각 로그에 **컨테이너 이름, 서비스 이름** 등의 라벨 자동 부여
3. **Loki**
    - Promtail이 전달한 로그를 수신 및 저장
    - 라벨 기반 검색이 가능해 특정 서비스/시간/에러 패턴 조회 가능

### 시각화

1. **Grafana**
    - Prometheus, Loki를 데이터 소스로 연결
    - 애플리케이션 상태, 시스템 리소스, 에러 로그 등 원하는 형태로 대시보드 구성
    - Slack/Webhook 등을 통해 알림 설정도 가능

## 접속 방법

### Grafana

[https://k12d103.p.ssafy.io/grafana](https://k12d103.p.ssafy.io/grafana)

### Prometheus

[https://k12d103.p.ssafy.io/prometheus](https://k12d103.p.ssafy.io/prometheus)

## 대시보드

### 📌 워치 센서 데이터 시각화

![image.png](resource/image_8.png)

### 📌 컨테이너 로그 수집 및 시각화

![image.png](resource/image_9.png)

### 📌 컨테이너 메트릭 수집 및 시각화

![image.png](resource/image_10.png)

![image.png](resource/image_11.png)

### 📌 시스템 메트릭 수집 및 성능/상태 시각화

![image.png](resource/image_12.png)